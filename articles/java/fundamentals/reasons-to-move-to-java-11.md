---
title: Java 11 に移行する理由
titleSuffix: Azure
description: Java 8 から Java 11 への移行の利点を検討している意思決定者を対象とした概要レベルのドキュメント。
author: dsgrieve
manager: maverbur
tags: java
ms.topic: article
ms.date: 11/19/2019
ms.author: dagrieve
ms.custom: devx-track-java
ms.openlocfilehash: b5c1ebe2a73a9f51811118c7190e607e9387ae42
ms.sourcegitcommit: 44016b81a15b1625c464e6a7b2bfb55938df20b6
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/14/2020
ms.locfileid: "86379806"
---
# <a name="reasons-to-move-to-java-11"></a>Java 11 に移行する理由

問題は、Java 11 に移行 "*すべき*" かどうかではなく、"*いつ*" 移行すべきかといいうことです。 今後数年以内に、Java 8 はサポートされなくなり、ユーザーは Java 11 に移行する必要があります。 Java 11 に移行することにはメリットがあり、できるだけ早くそのようにすることをお勧めします。

Java 8 以降、新機能が追加され、機能強化が行われてきました。 API には大幅な追加と変更が行われました。また、起動、パフォーマンス、メモリの使用量が向上する拡張機能も行われています。

## <a name="transitioning-to-java-11"></a>Java 11 への移行

Java 11 への移行は、手順を追って行うことができます。 Java 11 で実行するためにコードで Java モジュールを使用する必要は "*ありません*"。 Java 11 を使用して、JDK 8 で開発およびビルドされたコードを実行できます。
ただし、主に非推奨の API、クラス ローダー、およびリフレクションに関する潜在的な問題がいくつかあります。

Microsoft Java Engineering グループには、[Java 8 から Java 11 への移行](./transition-from-java-8-to-java-11.md)に関するガイドがあります。 「[Java Platform, Standard Edition Oracle JDK 9 Migration Guide (Java Platform、Standard Edition Oracle JDK 9 移行ガイド)](https://docs.oracle.com/javase/9/migrate/toc.htm)」と「[The State of the Module System: Compatibility and Migration (モジュール システムの状態: 互換性と移行)](http://openjdk.java.net/projects/jigsaw/spec/sotms/#compatibility--migration)」もお勧めのガイドです。 

## <a name="high-level-changes-between-java-8-and-11"></a>Java 8 と 11 の間の高レベルの変更

このセクションには、Java バージョン 9 \[[1](#ref1)\]、10 \[[2](#ref2)\]、および 11 \[[3](#ref3)\] に加えられたすべての変更が挙げられているわけではありません。 パフォーマンス、診断、生産性に影響を与える変更について紹介しています。

### <a name="modules-4"></a>モジュール \[[4](#ref4)\]

モジュールは、"*クラスパス*" で実行されている大規模なアプリケーションでは管理が困難な構成とカプセル化の問題に対処します。 "*モジュール*" は、Java クラスとインターフェイス、および関連リソースの自己記述型のコレクションです。

モジュールを使用すると、アプリケーションに必要なコンポーネントのみを含むランタイム構成をカスタマイズできます。 このカスタマイズによって、占有領域が小さくなり、アプリケーションを [jlink](https://docs.oracle.com/en/java/javase/11/tools/jlink.html) を使用して、デプロイ用のカスタム ランタイムに静的にリンクできます。 この小さい占有領域は、マイクロサービス アーキテクチャで特に役立ちます。

内部的には、JVM は、モジュールを利用してクラスの読み込み効率を高めることができます。 結果として、小さく、軽く、起動が高速なランタイムが実現します。 クラスで必要なコンポーネントがモジュールによりエンコードされるため、アプリケーションのパフォーマンスを向上させるために JVM によって使用される最適化手法が、より効果的になります。

プログラマにとっては、モジュールがエクスポートするパッケージと、それに必要なコンポーネントの明示的な宣言を強制し、リフレクティブ アクセスを制限することによって、モジュールは強力なカプセル化を適用するのに役立ちます。
このレベルのカプセル化により、アプリケーションのセキュリティが向上し、保守が容易になります。

アプリケーションでは引き続き "*クラスパス*" を使用でき、Java 11 で実行するための要件としてモジュールに移行する必要はありません。

### <a name="profiling-and-diagnostics"></a>プロファイルと診断

#### <a name="java-flight-recorder-5"></a>Java Flight Recorder \[[5](#ref5)\]

Java Flight Recorder (JFR) は、実行中の Java アプリケーションから診断データとプロファイル データを収集します。 JFR は、実行中の Java アプリケーションにほとんど影響しません。 収集したデータは、Java Mission Control (JMC) などのツールを使用して分析できます。 JFR と JMC は Java 8 では商用機能でしたが、どちらも Java 11 ではオープンソースです。

#### <a name="java-mission-control-6"></a>Java Mission Control \[[6](#ref6)\]

Java Mission Control (JMC) は、Java Flight Recorder (JFR) で収集されたデータをグラフィカルに表示し、また Java のオープンソースです。
11. JMC では、実行中のアプリケーションに関する一般的な情報に加えて、ユーザーがデータをドリルダウンすることができます。 JFR と JMC を使用して、メモリ リーク、GC のオーバーヘッド、ホット メソッド、スレッドのボトルネック、ブロッキング I/O などのランタイムの問題を診断できます。

#### <a name="unified-logging-7"></a>統合ログ \[[7](#ref7)\]

Java 11 には、JVM のすべてのコンポーネントに共通のログ記録システムがあります。
この統合されたログ記録システムにより、ユーザーはログに記録するコンポーネントとそのレベルを定義できます。 この詳細なログ記録は、JVM のクラッシュに関する根本原因分析の実行や、運用環境でのパフォーマンスの問題の診断に役立ちます。

#### <a name="low-overhead-heap-profiling-8"></a>オーバーヘッドの低いヒープ プロファイル \[[8](#ref8)\]

Java ヒープ割り当てをサンプリングするための新しい API が Java Virtual Machine Tool Interface (JVMTI) に追加されました。 サンプリングのオーバーヘッドは低く、継続的に有効にすることができます。 ヒープ割り当ては Java Flight Recorder (JFR) で監視できますが、JFR のサンプリング メソッドは割り当てに対してのみ機能します。 JFR 実装では、割り当てが見つからない場合もあります。 これに対して、Java 11 のヒープ サンプリングでは、ライブ オブジェクトと dead オブジェクトの両方に関する情報を提供できます。

アプリケーション パフォーマンス監視 (APM) のベンダーは、この新機能を利用し始めており、Java Engineering Group では、Azure パフォーマンス監視ツールでの使用の可能性を調査しています。

#### <a name="stackwalker-9"></a>StackWalker \[[9](#ref9)\]

ログを記録するときに、現在のスレッドのスタックのスナップショットがよく取得されます。 問題は、ログに記録するスタック トレースの量と、そもそもスタック トレースをログに記録するかどうかです。 たとえば、あるメソッドからの特定の例外についてのみ、スタック トレースを確認したい場合があります。 StackWalker クラス (Java 9 で追加) は、スタックのスナップショットを提供し、プログラマがスタック トレースの使用方法をきめ細かく制御できるようにするメソッドを提供します。

### <a name="garbage-collection-10"></a>ガベージ コレクション \[[10](#ref10)\]

Java 11 では、次のガベージ コレクターを使用できます。シリアル、パラレル、ガベージファースト、および Epsilon。 Java 11 の既定のガベージ コレクターは、ガベージファースト ガベージ コレクター (G1GC) です。

その他の 3 つのコレクターを補完のために紹介します。 Z ガベージ コレクター (ZGC) は、一時停止の時間を 10 ミリ秒以下に維持しようとする、同時実行の待機時間が短いコレクターです。 ZGC は、Java 11 の試験的な機能として利用できます。 Shenandoah コレクタは、実行中の Java プログラムと同時により多くのガベージ コレクションを実行することで、GC の一時停止時間を短縮する、待機時間の短いコレクターです。
Shenandoah は Java 12 の実験的な機能ですが、Java 11 に移植されています。 コンカレント マーク スイープ コレクター (CMS) は使用できますが、Java 9 以降は非推奨となりました。

JVM では、平均的なのユースケース向けに GC の既定値が設定されます。 多くの場合、これらの既定値とその他の GC 設定は、アプリケーションの要件に従って、最適なスループットまたは待機時間に合わせて調整する必要があります。
GC を適切にチューニングするには、[Microsoft Java Engineering Group](mailto:javaplatformgroup@microsoft.com) が提供する、GC に関する深い知識が必要です。

#### <a name="g1gc"></a>G1GC

Java 11 の既定のガベージ コレクターは、G1 ガベージ コレクター (G1GC) です。 G1GC の目的は、待機時間とスループットのバランスを取ることです。 G1 ガベージコレクターは、高い確率で一時停止時間の目標を満たすことで、高いスループットを達成しようとします。 G1GC は完全なコレクションを回避するように設計されていますが、\'同時実行コレクションがメモリの再利用を十分に高速に行うことができない場合は、フォールバックの完全な GC が発生します。 完全な GC では、young コレクションと混合コレクションと同じ数の並列ワーカー スレッドが使用されます。

#### <a name="parallel-gc"></a>パラレル GC

パラレル コレクターは、Java 8 の既定のコレクターです。 パラレル GC は、複数のスレッドを使用してガベージ コレクションを高速化するスループット コレクターです。

#### <a name="epsilon-11"></a>Epsilon \[[11](#ref11)\]

Epsilon ガベージ コレクターは割り当てを処理しますが、メモリを再利用することはありません。 ヒープが使い果たされると、JVM はシャットダウンします。
Epsilon は、短期間のサービスや、ガベージフリーであることが判明しているアプリケーションに向いています。

#### <a name="improvements-for-docker-containers-12"></a>Docker コンテナーの改善 \[[12](#ref12)\]

Java 10 より前では、コンテナーに設定されているメモリと CPU の制約は JVM によって認識されませんでした。 たとえば Java 8 では、JVM によって、最大ヒープ サイズは基になるホストの物理メモリの 1/4 に設定されます。 Java 10 以降では、JVM はコンテナー コントロール グループ (cgroups) によって設定された制約を使用して、メモリと CPU の制限を設定します (下記の注を参照してください)。
たとえば、既定の最大ヒープ サイズは、コンテナーのメモリ制限の1/4 です (例: -m2G の場合 500 MB)。

JVM オプションも追加されました。これにより、Docker コンテナーのユーザーは、Java ヒープに使用されるシステム メモリの量をきめ細かく制御できるようになります。

このサポートは既定で有効になっており、Linux ベースのプラットフォームでのみ使用できます。

> [!NOTE]
> cgroup の有効化作業のほとんどは、jdk8u191 の時点で Java 8 に移植されました。 今後の改善は、必ずしも 8 に移植されるとは限りません。

#### <a name="multi-release-jar-files-13"></a>マルチリリース jar ファイル \[[13](#ref13)\]

Java 11 では、Java リリース固有の、複数のバージョンのクラス ファイルを含む jar ファイルを作成できます。 マルチリリースの jar ファイルを使用することで、ライブラリ開発者は複数のバージョンの jar ファイルを配布せずに、複数のバージョンの Java をサポートできるようになります。 これらのライブラリの利用者にとっては、マルチリリース jar ファイルにより、特定の jar ファイルを特定のランタイム ターゲットに一致させる必要があるという問題が解決します。

## <a name="miscellaneous-performance-improvements"></a>その他のパフォーマンスの強化

JVM に対する次の変更は、パフォーマンスに直接影響します。

-   **JEP 197:セグメント化されたコード キャッシュ** \[[14](#ref14)\] - コード キャッシュを個別のセグメントに分割します。 このセグメント化により、JVM のメモリ占有領域の制御が向上し、コンパイルされたメソッドのスキャン時間が短縮され、コード キャッシュの断片化が大幅に減少し、パフォーマンスが向上します。

-   **JEP 254:文字列の圧縮** \[[15](#ref15)\] - 文字エンコードに応じて、文字列の内部表現を文字あたり 2 バイトから文字あたり 1 バイトまたは 2 バイトに変更します。 ほとんどの文字列には ISO-8859-1/Latin-1 文字が含まれているため、この変更によって、文字列を格納するために必要な領域の量が実質的に半分になります。

-   **JEP 310:アプリケーション クラス データ共有** \[[16](#ref16)\] - クラス データ共有では、アーカイブされたクラスを実行時にメモリにマップできるようにすることで、起動時間を短縮します。 アプリケーション クラス データ共有は、アプリケーション クラスを CDS アーカイブに配置できるようにすることで、クラス データ共有を拡張します。 複数の JVM が同じアーカイブ ファイルを共有すると、メモリが節約され、システム全体の応答時間が短縮されます。

-   **JEP 312:スレッドローカル ハンドシェイク** \[[17](#ref17)\] - グローバル VM safepoint を実行せずにスレッドでコールバックを実行できるようにします。これにより、グローバル safepoint の数を減らすことで VM の待機時間を短縮できます。

-   **コンパイラ スレッドのレイジー割り当て** \[[18](#ref18)\] - 階層化されたコンパイル モードでは、VM は多数のコンパイラ スレッドを開始します。
    このモードは、多くの CPU を搭載したシステムでは既定です。 これらのスレッドは、使用可能なメモリまたはコンパイル要求の数に関係なく作成されます。 スレッドは、アイドル状態 (ほぼすべての時間) であってもメモリを消費するため、リソースの非効率な使用につながります。 この問題に対処するために、起動時に各種類のコンパイラ スレッドを 1 つだけ開始するように実装が変更されています。 追加スレッドの開始と、未使用スレッドのシャットダウンは、動的に処理されます。 

コア ライブラリに対する次の変更は、新規または変更されたコードのパフォーマンスに影響を与えます。

-   **JEP 193:変数ハンドル** \[[19](#ref19)\] - オブジェクトのフィールドや配列要素に対してさまざまな java.util.concurrent.atomic および sun.misc.Unsafe 操作と同等のものを呼び出すための標準的な手段、メモリ並べ替えの詳細な制御のためのフェンス操作の標準セット、および参照オブジェクトを確実にアクセス可能なままにするための標準 reachability-fence 操作を定義します。

-   **JEP 269:コレクションの便利なファクトリ メソッド** \[[20](#ref20)\] - 少数の要素でコレクションとマップのインスタンスを作成するのに便利なライブラリ API を定義します。 コンパクトで変更できないコレクション インスタンスを作成する、コレクション インターフェイスの静的ファクト リメソッドです。 これらのインスタンスは、本質的に効率的です。 API により、コンパクトに表現され、ラッパー クラスを持たないコレクションが作成されます。

-   **JEP 285:スピン待機ヒント** \[[21](#ref21)\] - Java がランタイム システムに対してスピン ループ状態にあることを通知できるようにする API を提供します。 特定のハードウェア プラットフォームは、スレッドがビジーウェイト状態にあることを示すソフトウェアの恩恵を受けます。

-   **JEP 321:HTTP クライアント (標準)** \[[22](#ref22)\] - HTTP/2 および WebSocket を実装する新しい HTTP クライアント API を提供します。従来の HttpURLConnection API に置き換えることができます。

## <a name="references"></a>References

<a id="ref1">\[1\]</a> Oracle Corporation、\"Java Development Kit 9 リリース ノート\" (オンライン)。 参照先: https://www.oracle.com/technetwork/java/javase/9u-relnotes-3704429.html.
(2019 年 11 月 13 日にアクセス)。

<a id="ref2">\[2\]</a> Oracle Corporation、\"Java Development Kit 10 リリース ノート\" (オンライン)。 参照先: https://www.oracle.com/technetwork/java/javase/10u-relnotes-4108739.html.
(2019 年 11 月 13 日にアクセス)。

<a id="ref3">\[3\]</a> Oracle Corporation、\"Java Development Kit 11 リリース ノート\" (オンライン)。 参照先: https://www.oracle.com/technetwork/java/javase/11u-relnotes-5093844.html.
(2019 年 11 月 13 日にアクセス)。

<a id="ref4">\[4\]</a> Oracle Corporation、\"Project Jigsaw\"、9 月22日、 
2017. (オンライン)。 参照先: http://openjdk.java.net/projects/jigsaw/.
(2019 年 11 月 13 日にアクセス)。

<a id="ref5">\[5\]</a> Oracle Corporation、\"JEP 328:Flight Recorder\"、2018 年 9 月 9 日。 (オンライン)。 参照先: http://openjdk.java.net/jeps/328. (2019 年 11 月 13 日にアクセス)。

<a id="ref6">\[6\]</a> Oracle Corporation、\"Mission Control\"、2019 年 4 月 25 日。 (オンライン)。 参照先: https://wiki.openjdk.java.net/display/jmc/Main. (2019 年 11 月 13 日にアクセス)。

<a id="ref7">\[7\]</a> Oracle Corporation、\"JEP 158:統合 JVM ログ\"、2019 年 2 月 14 日。 (オンライン)。 参照先: http://openjdk.java.net/jeps/158.
(2019 年 11 月 13 日にアクセス)。

<a id="ref8">\[8\]</a> Oracle Corporation、\"JEP 331:オーバーヘッドの低いヒープ プロファイル\"、2018 年 9 月 5 日。 (オンライン)。 参照先: http://openjdk.java.net/jeps/331. (2019 年 11 月 13 日にアクセス)。

<a id="ref9">\[9\]</a> Oracle Corporation、\"JEP 259:Stack-Walking API\"、2017 年 7 月 18 日。 (オンライン)。
参照先: http://openjdk.java.net/jeps/259. (2019 年 11 月 13 日にアクセス)。

<a id="ref10">\[10\]</a> Oracle Corporation、\"JEP 248:G1 を既定のガベージ コレクターにする\"、2017 年 9 月 12 日。 (オンライン)。 参照先: http://openjdk.java.net/jeps/248. (2019 年 11 月 13 日にアクセス)。

<a id="ref11">\[11\]</a> Oracle Corporation、\"JEP 318:Epsilon:非操作ガベージ コレクター\"、2018 年 9 月 24 日。
(オンライン)。 参照先: http://openjdk.java.net/jeps/318. (2019 年 11 月 13 日にアクセス)。

<a id="ref12">\[12\]</a> Oracle Corporatio、\"JDK-8146115:Docker コンテナーの検出とリソース構成の使用の改善\"、2019 年 9 月 16 日。
(オンライン)。 参照先: https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8146115.
(2019 年 11 月 13 日にアクセス)。

<a id="ref13">\[13\]</a> Oracle Corporation、\"JEP 238:マルチリリース jar ファイル\"、2017 年 6 月 22 日。 (オンライン)。 参照先: http://openjdk.java.net/jeps/238. (2019 年 11 月 13 日にアクセス)。

<a id="ref14">\[14\]</a> Oracle Corporation、\"JEP 197:セグメント化コード キャッシュ\"、2017 年 4 月 28 日。 (オンライン)。
参照先: http://openjdk.java.net/jeps/197. (2019 年 11 月 13 日にアクセス)。

<a id="ref15">\[15\]</a> Oracle Corporation、\"JEP 254:文字列の圧縮\"、2019 年 5 月 18 日。 (オンライン)。 参照先: http://openjdk.java.net/jeps/254.
(2019 年 11 月 13 日にアクセス)。

<a id="ref16">\[16\]</a> Oracle Corporation、\"JEP 310:アプリケーション クラス データ共有\"、2018 年 8 月 17 日。 (オンライン)。 参照先: https://openjdk.java.net/jeps/310. (2019 年 11 月 13 日にアクセス)。

<a id="ref17">\[17\]</a> Oracle Corporation、\"JEP 312:スレッドローカル ハンドシェイク\"、2019 年 8 月 21 日。
(オンライン)。 参照先: https://openjdk.java.net/jeps/312. (2019 年 11 月 13 日にアクセス)。

<a id="ref18">\[18\]</a> Oracle Corporation、\"JDK-8198756:コンパイラ スレッドのレイジー割り当て\"、2018 年 10 月 29 日。 (オンライン)。 参照先: https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8198756.
(2019 年 11 月 13 日にアクセス)。

<a id="ref19">\[19\]</a> Oracle Corporation、\"JEP 193:変数ハンドル\"、2017 年 8 月 17 日。 (オンライン)。 参照先: https://openjdk.java.net/jeps/193. (2019 年 11 月 13 日にアクセス)。

<a id="ref20">\[20\]</a> Oracle Corporation、\"JEP 269:コレクションの便利なファクトリ メソッド\"、2017 年 6 月 26 日。 (オンライン)。 参照先: https://openjdk.java.net/jeps/269.
(2019 年 11 月 13 日にアクセス)。

<a id="ref21">\[21\]</a> Oracle Corporation、\"JEP 285:スピン待機ヒント\"、2017 年 8 月 20 日。 (オンライン)。 参照先: https://openjdk.java.net/jeps/285. (2019 年 11 月 13 日にアクセス)。

<a id="ref22">\[22\]</a> Oracle Corporation、\"JEP 321:HTTP クライアント (標準)\"、2018 年 9 月 27 日。 (オンライン)。
参照先: https://openjdk.java.net/jeps/321. (2019 年 11 月 13 日にアクセス)。
